# src/modules/cybersecurity/vulnerability_scanner.py

import logging
import os
import json
import subprocess
from datetime import datetime, time
from typing import Any, Dict, Optional

from dotenv import load_dotenv
import pandas as pd

# Import MetadataStorage from data_management module
from src.modules.data_management.metadata_storage import MetadataStorage

# Import NotificationManager from notifications module
from src.modules.notifications.notification_manager import NotificationManager

# Load environment variables from .env file
load_dotenv()

# Configure logging with RotatingFileHandler to prevent log files from becoming too large
from logging.handlers import RotatingFileHandler

from src.utils.logger import get_logger

logger = get_logger(__name__, 'logs/vulnerability_scanner.log')


class VulnerabilityScanner:
    """
    Scans code, dependencies, and configurations to identify known vulnerabilities.
    Provides detailed reports on vulnerabilities found, including severity levels and suggested fixes.
    """

    def __init__(self):
        """
        Initializes the VulnerabilityScanner with necessary configurations.
        """
        # Initialize Metadata Storage
        self.metadata_storage = MetadataStorage()

        # Initialize Notification Manager
        self.notification_manager = NotificationManager()

        # Configuration parameters
        self.project_dir = os.getenv('VULNERABILITY_SCANNER_PROJECT_DIR', '/path/to/your/project')
        self.scan_interval = int(os.getenv('VULNERABILITY_SCANNER_SCAN_INTERVAL', '86400'))  # in seconds
        self.report_output_dir = os.getenv('VULNERABILITY_SCANNER_REPORT_DIR', 'reports/vulnerability_scans')

        # Ensure report directory exists
        os.makedirs(self.report_output_dir, exist_ok=True)

        logger.info("VulnerabilityScanner initialized successfully.")

    def run_bandit_scan(self) -> Optional[str]:
        """
        Runs Bandit to perform static code analysis on the project directory.

        :return: Path to the Bandit JSON report or None if the scan fails.
        """
        try:
            report_path = os.path.join(self.report_output_dir, f'bandit_report_{datetime.utcnow().strftime("%Y%m%d%H%M%S")}.json')
            command = ['bandit', '-r', self.project_dir, '-f', 'json', '-o', report_path]
            logger.info(f"Running Bandit scan with command: {' '.join(command)}")
            subprocess.run(command, check=True)
            logger.info(f"Bandit scan completed successfully. Report saved to {report_path}")
            return report_path
        except subprocess.CalledProcessError as e:
            logger.error(f"Bandit scan failed: {e}")
            return None

    def run_safety_scan(self) -> Optional[str]:
        """
        Runs Safety to check Python dependencies for known vulnerabilities.

        :return: Path to the Safety JSON report or None if the scan fails.
        """
        try:
            report_path = os.path.join(self.report_output_dir, f'safety_report_{datetime.utcnow().strftime("%Y%m%d%H%M%S")}.json')
            command = ['safety', 'check', '--json', '--output', report_path]
            logger.info(f"Running Safety scan with command: {' '.join(command)}")
            subprocess.run(command, check=True, cwd=self.project_dir)
            logger.info(f"Safety scan completed successfully. Report saved to {report_path}")
            return report_path
        except subprocess.CalledProcessError as e:
            logger.error(f"Safety scan failed: {e}")
            return None

    def run_checkov_scan(self) -> Optional[str]:
        """
        Runs Checkov to scan infrastructure as code configurations for vulnerabilities.

        :return: Path to the Checkov JSON report or None if the scan fails.
        """
        try:
            report_path = os.path.join(self.report_output_dir, f'checkov_report_{datetime.utcnow().strftime("%Y%m%d%H%M%S")}.json')
            command = ['checkov', '-d', self.project_dir, '--output', 'json', '--output-file', report_path]
            logger.info(f"Running Checkov scan with command: {' '.join(command)}")
            subprocess.run(command, check=True)
            logger.info(f"Checkov scan completed successfully. Report saved to {report_path}")
            return report_path
        except subprocess.CalledProcessError as e:
            logger.error(f"Checkov scan failed: {e}")
            return None

    def parse_bandit_report(self, report_path: str) -> pd.DataFrame:
        """
        Parses the Bandit JSON report into a DataFrame.

        :param report_path: Path to the Bandit JSON report.
        :return: DataFrame containing parsed Bandit findings.
        """
        try:
            with open(report_path, 'r') as f:
                data = json.load(f)

            findings = data.get('results', [])
            df = pd.json_normalize(findings)
            logger.info(f"Parsed {len(df)} Bandit findings from report.")
            return df
        except Exception as e:
            logger.error(f"Failed to parse Bandit report '{report_path}': {e}")
            return pd.DataFrame()

    def parse_safety_report(self, report_path: str) -> pd.DataFrame:
        """
        Parses the Safety JSON report into a DataFrame.

        :param report_path: Path to the Safety JSON report.
        :return: DataFrame containing parsed Safety findings.
        """
        try:
            with open(report_path, 'r') as f:
                data = json.load(f)

            vulnerabilities = data.get('vulnerabilities', [])
            df = pd.json_normalize(vulnerabilities)
            logger.info(f"Parsed {len(df)} Safety findings from report.")
            return df
        except Exception as e:
            logger.error(f"Failed to parse Safety report '{report_path}': {e}")
            return pd.DataFrame()

    def parse_checkov_report(self, report_path: str) -> pd.DataFrame:
        """
        Parses the Checkov JSON report into a DataFrame.

        :param report_path: Path to the Checkov JSON report.
        :return: DataFrame containing parsed Checkov findings.
        """
        try:
            with open(report_path, 'r') as f:
                data = json.load(f)

            checks = data.get('results', [])
            df = pd.json_normalize(checks)
            logger.info(f"Parsed {len(df)} Checkov findings from report.")
            return df
        except Exception as e:
            logger.error(f"Failed to parse Checkov report '{report_path}': {e}")
            return pd.DataFrame()

    def generate_vulnerability_report(self, bandit_df: pd.DataFrame, safety_df: pd.DataFrame, checkov_df: pd.DataFrame) -> Dict[str, Any]:
        """
        Aggregates findings from different scans into a consolidated report.

        :param bandit_df: DataFrame containing Bandit findings.
        :param safety_df: DataFrame containing Safety findings.
        :param checkov_df: DataFrame containing Checkov findings.
        :return: Dictionary representing the consolidated vulnerability report.
        """
        report = {
            'timestamp': datetime.utcnow().isoformat(),
            'bandit_findings': bandit_df.to_dict(orient='records'),
            'safety_findings': safety_df.to_dict(orient='records'),
            'checkov_findings': checkov_df.to_dict(orient='records')
        }
        logger.info("Generated consolidated vulnerability report.")
        return report

    def save_report(self, report: Dict[str, Any], report_name: str):
        """
        Saves the consolidated vulnerability report to a JSON file and stores metadata.

        :param report: Dictionary representing the vulnerability report.
        :param report_name: Name identifier for the report.
        """
        try:
            report_file_path = os.path.join(self.report_output_dir, f'{report_name}_{datetime.utcnow().strftime("%Y%m%d%H%M%S")}.json')
            with open(report_file_path, 'w') as f:
                json.dump(report, f, indent=4)
            logger.info(f"Saved vulnerability report to {report_file_path}")

            # Save metadata to Metadata Storage
            self.metadata_storage.save_metadata(report, storage_type='vulnerability_scan')

            # Optionally, send notifications for critical vulnerabilities
            self.notify_critical_vulnerabilities(report)
        except Exception as e:
            logger.error(f"Failed to save vulnerability report '{report_name}': {e}")

    def notify_critical_vulnerabilities(self, report: Dict[str, Any]):
        """
        Sends notifications if critical vulnerabilities are found.

        :param report: Dictionary representing the vulnerability report.
        """
        try:
            critical_vulns = []

            # Define severity thresholds
            bandit_severity = {'LOW': 1, 'MEDIUM': 2, 'HIGH': 3, 'CRITICAL': 4}
            safety_severity = {'LOW': 1, 'MEDIUM': 2, 'HIGH': 3, 'CRITICAL': 4}
            checkov_severity = {'LOW': 1, 'MEDIUM': 2, 'HIGH': 3, 'CRITICAL': 4}

            # Extract critical Bandit findings
            if 'bandit_findings' in report:
                critical_bandit = [v for v in report['bandit_findings'] if bandit_severity.get(v.get('issue_severity', '').upper(), 0) >= 3]
                critical_vulns.extend(critical_bandit)

            # Extract critical Safety findings
            if 'safety_findings' in report:
                critical_safety = [v for v in report['safety_findings'] if safety_severity.get(v.get('severity', '').upper(), 0) >= 3]
                critical_vulns.extend(critical_safety)

            # Extract critical Checkov findings
            if 'checkov_findings' in report:
                critical_checkov = [v for v in report['checkov_findings'] if checkov_severity.get(v.get('severity', '').upper(), 0) >= 3]
                critical_vulns.extend(critical_checkov)

            if critical_vulns:
                subject = f"Critical Vulnerabilities Detected in Project: {self.project_dir}"
                message = f"The following critical vulnerabilities were detected:\n\n"
                for vuln in critical_vulns:
                    if 'test_id' in vuln:
                        message += f"[{vuln.get('test_id')}] {vuln.get('check_name')}: {vuln.get('issue_text')}\n"
                    elif 'name' in vuln:
                        message += f"[{vuln.get('name')}] {vuln.get('description')}: {vuln.get('fix')}\n"
                    else:
                        message += f"{vuln}\n"

                success = self.notification_manager.send_notification(subject, message, channel='email')
                if success:
                    logger.info("Critical vulnerability alert sent via email.")
                else:
                    logger.error("Failed to send critical vulnerability alert via email.")

        except Exception as e:
            logger.error(f"Failed to send notifications for critical vulnerabilities: {e}")

    def run_scans(self):
        """
        Executes all vulnerability scans and generates reports.
        """
        # Run Bandit scan
        bandit_report_path = self.run_bandit_scan()
        bandit_df = self.parse_bandit_report(bandit_report_path) if bandit_report_path else pd.DataFrame()

        # Run Safety scan
        safety_report_path = self.run_safety_scan()
        safety_df = self.parse_safety_report(safety_report_path) if safety_report_path else pd.DataFrame()

        # Run Checkov scan (optional)
        checkov_report_path = self.run_checkov_scan()
        checkov_df = self.parse_checkov_report(checkov_report_path) if checkov_report_path else pd.DataFrame()

        # Generate consolidated report
        consolidated_report = self.generate_vulnerability_report(bandit_df, safety_df, checkov_df)

        # Save report
        self.save_report(consolidated_report, 'vulnerability_scan')

    def run_periodic_scans(self):
        """
        Runs vulnerability scans at configured intervals indefinitely.
        """
        logger.info("Starting periodic vulnerability scans.")
        while True:
            try:
                logger.info("Initiating vulnerability scans.")
                self.run_scans()
                logger.info(f"Sleeping for {self.scan_interval} seconds before next scan cycle.")
                time.sleep(self.scan_interval)
            except KeyboardInterrupt:
                logger.info("VulnerabilityScanner stopped manually.")
                break
            except Exception as e:
                logger.exception(f"An unexpected error occurred during vulnerability scans: {e}")
                time.sleep(self.scan_interval)


if __name__ == "__main__":
    try:
        scanner = VulnerabilityScanner()
        scanner.run_periodic_scans()
    except Exception as e:
        logger.exception(f"Failed to start VulnerabilityScanner: {e}")
